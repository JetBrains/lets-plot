/*
 * Copyright (c) 2025. JetBrains s.r.o.
 * Use of this source code is governed by the MIT license that can be found in the LICENSE file.
 */

package org.jetbrains.letsPlot.raster.mapping.svg

import org.jetbrains.letsPlot.commons.intern.math.toRadians
import org.jetbrains.letsPlot.core.canvas.Path2d

class SvgPathParser(private val pathData: String) {
    companion object {
        fun parse(pathData: String): Path2d {
            return SvgPathParser(pathData).parse()
        }
    }

    private var index = 0
    private val length = pathData.length

    fun parse(): Path2d {
        val path = Path2d()
        var curX = 0.0
        var curY = 0.0
        var currentCommand: Char? = null

        while (index < length) {
            skipWhitespaceAndComma()
            if (index >= length) break

            val char = pathData[index]
            if (char.isLetter()) {
                currentCommand = char
                index++
                skipWhitespaceAndComma()
            }

            when (currentCommand) {
                'M', 'm' -> {
                    if (currentCommand == 'M') {
                        curX = readNumber()
                        curY = readNumber()
                    } else {
                        curX += readNumber()
                        curY += readNumber()
                    }

                    path.moveTo(curX, curY)
                    currentCommand = if (currentCommand == 'M') 'L' else 'l'
                }

                'L', 'l' -> {
                    if (currentCommand == 'L') {
                        curX = readNumber()
                        curY = readNumber()
                    } else {
                        curX += readNumber()
                        curY += readNumber()
                    }
                    path.lineTo(curX, curY)
                }

                'A', 'a' -> {
                    val rx = readNumber()
                    val ry = readNumber()
                    val angle = toRadians(readNumber())
                    val largeArcFlag = readNumber().toInt() != 0
                    val sweepFlag = readNumber().toInt() != 0
                    val x = readNumber()
                    val y = readNumber()

                    val (newX, newY) = when (currentCommand) {
                        'A' -> x to y
                        'a' -> x + curX to y + curY
                        else -> error("Should not happen")
                    }

                    path.arc(
                        x1 = curX, y1 = curY,
                        x2 = newX, y2 = newY,
                        rxIn = rx, ryIn = ry,
                        angle = angle, largeArcFlag = largeArcFlag, sweepFlag = sweepFlag,
                        connect = false // prevent lineTo(x1, y1) generated by Path2d - the curPoint is already there
                    )

                    curX = newX
                    curY = newY
                }

                'H', 'h' -> {
                    if (currentCommand == 'H') {
                        curX = readNumber()
                    } else {
                        curX += readNumber()
                    }
                    path.lineTo(curX, curY)
                }

                'V', 'v' -> {
                    if (currentCommand == 'V') {
                        curY = readNumber()
                    } else {
                        curY += readNumber()
                    }
                    path.lineTo(curX, curY)
                }

                'C', 'c' -> {
                    val (dx, dy) = if (currentCommand == 'C') 0.0 to 0.0 else curX to curY

                    val x1 = readNumber() + dx
                    val y1 = readNumber() + dy
                    val x2 = readNumber() + dx
                    val y2 = readNumber() + dy
                    val x = readNumber() + dx
                    val y = readNumber() + dy

                    path.bezierCurveTo(x1, y1, x2, y2, x, y)
                    curX = x
                    curY = y
                }


                'Z', 'z' -> {
                    path.closePath()
                }

                else -> error("Unsupported command: $currentCommand at position $index")
            }
        }

        return path
    }

    private fun skipWhitespaceAndComma() {
        while (index < length && (pathData[index].isWhitespace() || pathData[index] == ',')) {
            index++
        }
    }

    private fun readNumber(): Double {
        skipWhitespaceAndComma()
        val start = index
        if (index < length && (pathData[index] == '-' || pathData[index] == '+')) {
            index++
        }
        while (index < length && (pathData[index].isDigit() || pathData[index] == '.')) {
            index++
        }
        val numberStr = pathData.substring(start, index)
        return numberStr.toDoubleOrNull() ?: error("Expected number at position $start")
    }


}