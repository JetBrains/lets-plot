plugins {
    id "org.jetbrains.kotlin.multiplatform" apply false
    id "org.jetbrains.kotlin.js" apply false
    id("io.github.gradle-nexus.publish-plugin") version "1.3.0"
}

import org.gradle.nativeplatform.platform.internal.DefaultNativePlatform as platform

project.ext.letsPlotTaskGroup = 'lets-plot'

allprojects {
    group = 'org.jetbrains.lets-plot'
    version = "4.2.1-SNAPSHOT"
    // see also: python-package/lets_plot/_version.py

    // Generate JVM 1.8 bytecode
    tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).configureEach {
        kotlinOptions.jvmTarget = "1.8"
    }

    tasks.withType(JavaCompile).configureEach {
        sourceCompatibility = "1.8"
        targetCompatibility = "1.8"
    }

    project.ext.jfx_platform = { -> //getJfxPlatform()
        def os = platform.currentOperatingSystem
        if (os.isWindows()) {
            return "win"
        } else if (os.isLinux()) {
            return "linux"
        } else if (os.isMacOsX()) {
            return "mac"
        } else {
            return "unknown"
        }
    }

    project.ext.jfx_platform_resolved = project.ext.jfx_platform()

    repositories {
        mavenCentral()
    }
}

// Read build settings from commandline parameters (for build_release.py script):
def readPropertiesFromParameters() {
    def properties = new Properties()
    if (project.hasProperty("enable_python_package")) {
        properties."enable_python_package" = project.getProperty("enable_python_package").toBoolean()
    }
    if (properties.enable_python_package) {
        properties."python.bin_path" = project.getProperty("python.bin_path")
        properties."python.include_path" = project.getProperty("python.include_path")
    }
    def os = platform.getCurrentOperatingSystem()
    if (!os.windows) {
        properties."architecture" = project.getProperty("architecture")
    }
    return properties
}

// Read build settings from local.properties:
def readPropertiesFromFile() {
    def os = platform.getCurrentOperatingSystem()
    def properties = new Properties()
    def localPropsFileName = "local.properties"

    if (project.file(localPropsFileName).exists()) {
        properties.load(project.file(localPropsFileName).newInputStream())
    } else {
        throw new FileNotFoundException("${localPropsFileName} file not found!\n" +
                "Check ${localPropsFileName}_template file for the template.")
    }
    properties."enable_python_package" = properties."enable_python_package".toBoolean()

    if (!os.windows) {
        assert properties."architecture" != null // Windows only 64bit version can be built, so the arch parameter is not needed and may not be set.
    }

    if (properties."enable_python_package") {

        def pythonBinPath = properties."python.bin_path"
        def pythonIncludePath = properties."python.include_path"

        assert pythonBinPath != null
        assert pythonIncludePath != null

        if (!os.windows) {
            def getArchOutput = new ByteArrayOutputStream()
            exec {
                commandLine "${pythonBinPath}/python",
                        "-c",
                        "import platform; print(platform.machine())"
                standardOutput = getArchOutput
            }
            def currentPythonArch = getArchOutput.toString().trim()

            if (currentPythonArch != properties."architecture") {
                throw new IllegalArgumentException("Project and Python architectures don't match!\n" +
                        " - Value, from your '${localPropsFileName}' file: ${properties.architecture}\n" +
                        " - Your Python architecture: ${currentPythonArch}\n" +
                        "Check your '${localPropsFileName}' file.")
            }
        }
    }
    return properties
}

// For build_release.py settings will be read from commandline parameters.
// In other cases, settings will be read from local.properties.
if (project.hasProperty("build_release")) {
    ext.localProps = readPropertiesFromParameters()
} else {
    ext.localProps = readPropertiesFromFile()
}


// Maven publication settings
// define local Maven Repository path:
project.ext.localMavenRepository = "$rootDir/.maven-publish-dev-repo"

// define Sonatype nexus repository manager settings:
nexusPublishing {
    repositories {
        maven {
            username = localProps."sonatype.username"
            password = localProps."sonatype.password"
            stagingProfileId = localProps."sonatype.profileID"
            nexusUrl.set(uri("https://oss.sonatype.org/service/local/"))
            snapshotRepositoryUrl.set(uri("https://oss.sonatype.org/content/repositories/snapshots/"))
        }
    }
}

// Publish some sub-projects as Kotlin Multiproject libraries.
task publishLetsPlotCoreModulesToMavenLocalRepository {
    group project.letsPlotTaskGroup
}
task publishLetsPlotCoreModulesToMavenRepository {
    group project.letsPlotTaskGroup
}

// Generating JavaDoc task for each publication task.
// Fixes "Task ':canvas:publishJsPublicationToMavenRepository' uses this output of task ':canvas:signJvmPublication'
// without declaring an explicit or implicit dependency" error.
// Issues:
//  - https://github.com/gradle-nexus/publish-plugin/issues/208
//  - https://github.com/gradle/gradle/issues/26091
//
def getJarJavaDocsTask(distributeName) {
    return tasks.register("${distributeName}${project.name}jarJavaDoc", Jar) {
        archiveClassifier.set("javadoc")
        from("$rootDir/README.md")
        archiveBaseName.set("${distributeName}")
    }
}

subprojects {
    // Configure Kotlin targets.
    // List of modules used in Python native extension:
    if (name in [
            'commons',
            'datamodel',
            'plot-base',
            'plot-builder',
            'plot-stem',
            'platf-native',
            'demo-and-test-shared',
    ]) {
        apply plugin: "org.jetbrains.kotlin.multiplatform"

        def os = platform.getCurrentOperatingSystem()

        kotlin {
            if (os.macOsX & localProps."architecture" == "x86_64") {
                macosX64()
            } else if (os.macOsX & localProps."architecture" == "arm64") {
                if (project.hasProperty("build_release")) {
                    macosX64()
                    macosArm64()
                } else {
                    macosArm64()
                }
            } else if (os.linux) {
                if (project.hasProperty("build_release")) {
                    linuxX64()
                    linuxArm64()
                } else if (project.localProps."architecture" == "x86_64") {
                    linuxX64()
                }
            } else if (os.windows) {
                mingwX64()
            } else {
                throw new Exception("Unsupported platform! Check project settings.")
            }
        }
    }

    // Configure publishing core artifacts.
    if (name in [
            'commons',
            'datamodel',
            'canvas',
            'gis',
            'livemap',
            'plot-base',
            'plot-builder',
            'plot-stem',
            'plot-livemap',
            'platf-awt',
            'platf-batik',
            'platf-jfx-swing',
            'deprecated-in-v4'
    ]) {
        apply plugin: "org.jetbrains.kotlin.multiplatform"
        kotlin.jvm {}   // for `jvmSourcesJar` task

        apply plugin: "maven-publish"
        apply plugin: "signing"

        // Do not publish 'native' targets.
        def publications_to_publish = ["jvm", "js", "kotlinMultiplatform", "metadata"]

        publishing {
            publications {
                withType(MavenPublication) {
                    if (name in publications_to_publish) {
                        // Configure this publication.

                        // "JavaDoc" artifact for all publications.
                        artifact getJarJavaDocsTask("${name}-${project.name}")

                        pom {
                            name = "Lets-Plot core artifact"
                            description = "A part of the Lets-Plot library."

                            url = "https://github.com/JetBrains/lets-plot"
                            licenses {
                                license {
                                    name = "MIT"
                                    url = "https://raw.githubusercontent.com/JetBrains/lets-plot/master/LICENSE"
                                }
                            }
                            developers {
                                developer {
                                    id = "jetbrains"
                                    name = "JetBrains"
                                    email = "lets-plot@jetbrains.com"
                                }
                            }
                            scm {
                                url = "https://github.com/JetBrains/lets-plot"
                            }
                        }
                    }
                }
            }
            repositories {
                mavenLocal {
                    url = uri(project.localMavenRepository)
                }
            }
        }

        afterEvaluate {

            // Add LICENSE file to the META-INF folder inside published JAR files
            jvmJar {
                metaInf {
                    from("$rootDir") {
                        include "LICENSE"
                    }
                }
            }

            // Configure artifacts signing process for release versions.
            def publications_to_sign = []

            for (task in it.tasks.withType(PublishToMavenRepository)) {
                if (task.getPublication().name in publications_to_publish) {
                    def repoName = task.repository.name
                    if (repoName == "MavenLocal") {
                        publishLetsPlotCoreModulesToMavenLocalRepository.dependsOn += task
                    } else if (repoName == "maven") {
                        publishLetsPlotCoreModulesToMavenRepository.dependsOn += task
                        publications_to_sign += task.getPublication()
                    } else {
                        throw new IllegalStateException("Repository expected: 'MavenLocal' or 'maven' but was: '$repoName'.")
                    }
                }
            }

            // Sign artifacts.
            publications_to_sign.each {
                if (!project.version.contains('SNAPSHOT')) {
                    signing.sign(it)
                }
            }
        }
    }
}
